<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Trees</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
</body>
</html>



<script>
/*
Trees:
Types:
- Binary tree - a tree with only 2 possible nodes. Nodes are added to the tree in breadth first fashion from left to right in each row
- Binary Search Tree - a binary tree where left node is <= parent, and right node is > parent


      1
      /\
    2   3
  /\
 4 5

Depth First Traversals:
(a) Inorder (Left, Root, Right) : 4 2 5 1 3
(b) Preorder (Root, Left, Right) : 1 2 4 5 3
(c) Postorder (Left, Right, Root) : 4 5 2 3 1

Breadth First or Level Order Traversal : 1 2 3 4 5
- implemented typically recursively since # of rows is unknown in a tree
- Traverses left to right on each row since it adds nodes to the queue left to right
- Time complexity O(n^2) where n is row number, row = 0 is the root node.
- Callstack has each recursive call made for each row of the tree. So for n rows = n calls on the callstack.
- Represented by a queue of all the nodes in each row, and each call is an evaluation of all the nodes in the queue for a given row.

binary search tree:
        5
        /\
      4   7
      /   /\
    3     6 8
   /
  2
/
1

Inorder on binary search tree = 1, 2, 3, 4, 5, 6, 7, 8  (left, root, right)
  - Inorder will return an array of values sorted in ascending order for a BST

Preorder on binary search tree = 5, 4, 3, 2, 1, 7, 6, 8 (root, left, right)
  - Preorder is used to create an array of values that if started from the front of the array to form a BST, you'd get the
  same result (ex. 5 then 4, then 3...to create the BST);
  - Preorder is used if you want to search all of the roots before diving into its leaves

Postorder on binary search tree = 1, 2, 3, 4, 6, 8, 7, 5 (left, right, root)
  - Use Postorder if you want to search all the leaves of any tree before searching the roots
  - Use it also to delete nodes from a tree since you delete the leaves before their parent

*/

function TreeNode(val) {
  this.val = val;
  this.left = null;
  this.right = null;
};

let treeA = new TreeNode(1);
treeA.left = new TreeNode(2);
treeA.right = new TreeNode(3);
treeA.right.left = new TreeNode(6);
treeA.right.right = new TreeNode(7);
treeA.left.left = new TreeNode(4);
treeA.left.right = new TreeNode(5);

console.log('Tree A ', treeA);
//------------------------
const inorderSearch = (targetVal, treeNode) => {

  //left, root, right is the traversal order

  //if treeNode has a left child
  if (treeNode.left) {
    //recurse with targetVal and treeNode.left
    let foundNode = inorderSearch(targetVal, treeNode.left);
      //set resultOfRecurse = the recurse return value
      //if the result is a node, search is over and return the node
      if (foundNode) return foundNode;
  }
  //if the treeNode's value is === target, return the node
  if (treeNode.val === targetVal) return treeNode;

  //if treeNode has a right child
  if (treeNode.right) {
    //recurse with the targetVal and treeNode.right
    let foundNode = inorderSearch(targetVal, treeNode.right);
      //set result to the return
      //if result is a node, search is over and return the node
      if (foundNode) return foundNode;
  }
  //if not found a valid value, return null
  return null;
};

console.log(inorderSearch(7, treeA));

//------------------------
const preorderSearch = (targetVal, treeNode) => {

  //root, left, right is the traversal order

  //check currentNode's value if equal to target
  if (treeNode.val === targetVal) return treeNode;
    //if it is, return the node

  //if currentNode has a left child,
  if (treeNode.left) {
    //recurse preorderSearch with target val and pass in the left node
    let foundNode = preorderSearch(targetVal, treeNode.left);
      //if the return of the recurse is a node, return it back up because search is over
      if (foundNode) return foundNode;
      //else if it is null, move onto next step
  }

  //if currentNode has a right child,
  if (treeNode.right) {
    //recurse preorderSearch with target val and pass in the right node
    let foundNode = preorderSearch(targetVal, treeNode.right);
      //if the return of the recurse is a node, return it back up because search is over
      if (foundNode) return foundNode;
      //else if it is null, move onto next step
  }
  //if there is no child nodes or done checking child nodes with no result, return null
  return null;
}

console.log(preorderSearch(6, treeA));

//------------------------
const postorderSearch = (targetVal, treeNode) => {
  //left right root is the traversal order

  if (treeNode.left) {
    let foundNode = postorderSearch(targetVal, treeNode.left);
    if (foundNode) return foundNode;
  }

  if (treeNode.right) {
    let foundNode = postorderSearch(targetVal, treeNode.right);
    if (foundNode) return foundNode;
  }

  if (treeNode.val === targetVal) return treeNode;
  return null;
};

console.log(postorderSearch(7, treeA));


//----------------------------------------------------------
// Breadth First:
/*
  Abstract concept:
  - Use a queue to fill it up with nodes and child nodes
  - Don't want to actively manage the queue except know that unless it is empty, keep using it
  - Analyze one row of nodes at a time

  - In the non-recursive option, the queue is a queue of all nodes from Left to right on each row. This version does not have a concept of rows that need to be actively managed unlike the recursive option where the recursive call represents the loop through a variable number of rows. So this is simply moving through and placing nodes into a queue and processing them one by one.

  function (node)
    - initiate queue with node

    - while the queue is not empty:
      - pop one off the queue
      - analyze that node for whatever criteria (ex. isTextNode or it's value is === target)
        - Perform action as a result of the analysis
      - check if it has kids
        - If it does, push them into the queue
          - (The order in which you push children in should be left to right since breadth first is left to right)

    - return with the end result of using BF to analyze all the ndoes


  - In the recursion option, you use the callstack to move row to row, where instead of one queue for all nodes, you have a queue for each row. Then you need a loop to go through each row's nodes.

  functionRecursion (node, queueOfRowNodes)
    - initiate recursive loop by setting queueOfRowNodes to [node] on the first iteration
    - For loop through the queueOfRowNodes selecting each node
      - analyze the node for whatever criteria
        - perform action as a result of the analysis
      - check if the node has kids
        - If so, push them into a new queue that represents the next row
    - Following the loop
      - if the next row's queue is empty, then return the result of the analysis/action
      - if the next row's queue is not empty, then recurse, passing in the next row's queueOfRowsNodes

  - Based on this breakdown, there are 2 loops being used for this one (recursive loop to move rows and for loop to go through each row), and while loop to go through the queue in the non-recursive route. The time complexity of both is the same since you have to visit each node in the same order.
*/

{
  const BFS_while = (target, node) => {
    let queue = [node]; //initialize before while loop

    while (queue.length) {
      //grab a node from the queue
      let currentNode = queue.shift();

      //analyze the node and perform action if it meets criteria
      if (currentNode.val === target) return currentNode;

      //Add its kids, if available, to the queue in Left then Right order
      if (currentNode.left) queue.push(currentNode.left);
      if (currentNode.right) queue.push(currentNode.right);
    }

    return null;
  };


  console.log('BFS_while ', BFS_while(5, treeA));
}

{
  const BFS_recursive = (targetVal, node, queueOfRowNodes) => {

    //Initialize the queueOfRowNodes at start of program:
    if (!queueOfRowNodes) queueOfRowNodes = [node];

    //Create storage for next row's nodes rather than use the same queue of this row's nodes.
    let nextRowsNodes = [];

    //Loop through the row's nodes. Note you can use a for loop too but since we are going to shift(i.e., remove) nodes from the queue, we can just set a simple while loop criteria instead of controlling each iteration:
    while (queueOfRowNodes.length) {
      //get next node from the queue
      let currentNode = queueOfRowNodes.shift();

      //Analyze the node and perform action if conditions are met
      if (currentNode.val === targetVal) return currentNode;

      //Add next row's nodes in Left Right order since it is BF
      if (currentNode.left) nextRowsNodes.push(currentNode.left);
      if (currentNode.right) nextRowsNodes.push(currentNode.right);
    }

    //After processed all current row's nodes, conditional for recursion:
    return (nextRowsNodes.length) ? BFS_recursive(targetVal, null, nextRowsNodes) : null;

  };

  console.log('BFS_recursive ', BFS_recursive(5, treeA));
}

</script>